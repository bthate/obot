#!/usr/bin/python3 -u

import os, sys ; sys.path.insert(0, os.getcwd())

import ob
import time

from ob import k, __version__
from ob.shl import execute, parse_cli
from ob.tms import elapsed
from ob.utl import hd

opts = [
    ('-b', '', 'store_true', False, 'daemon', 'enable daemon mode.'),
    ('-d', '', 'string', "", 'workdir', 'set working directory.'),
    ('-k', '', 'store_true', False, 'kernel', 'use saved kernel config'),
    ('-l', '', 'string', '', 'level', 'loglevel.'),
    ('-m', '', 'string', '', 'modules', 'modules to load.'),
    ('-n', '', 'string', 'obot', 'name', "program name."),
    ('-o', '', "string", "", 'options', "options to use."),
    ('-p', '', 'store_true', False, 'prompting', 'prompt for initial values.'),
    ('-r', '', 'store_true', False, 'resume', 'resume the bot.'),
    ('-s', '', 'store_true', False, 'dosave', 'save configuration files.'),
    ('-t', '', 'store_true', False, 'tables', 'dump tables.'),
    ('-v', '', 'store_true', False, 'verbose', 'enable verbose mode.'),
    ('-x', '', 'string', '', 'exclude', 'skip modules'),
    ('-z', '', 'store_true', False, 'noshell', 'disable shell.'),
    ('', '--autoload', 'store_true', False, 'autoload', 'use on demand module loading.'),
    ('', '--bork', 'store_true', False, 'bork', 'bork on exception.'),
    ('', '--cached', 'store_true', False, 'cached', 'use caching'),
    ('', '--debug', "string", "", 'debug', "enable debug mode"),
    ('', '--logdir', "string", "", 'logdir', "directory to log to."),
    ('', '--owner', "string", "", 'owner', "owner's userhost or JID."),
    ('', '--nousers', 'store_true', False, 'nousers', 'disabled users.'),
]

def ed(event):
    """ edit an object, select with key==value, set with key=value. """
    if not event.args:
        fns = os.listdir(os.path.join(ob.workdir, "store"))
        fns = sorted({x.split(".")[-1].lower() for x in fns})
        event.reply("|".join(fns))
        return
    if len(event.args) == 1 and not event.selector:
        event.reply("ed <type> key==value")
        return
    objs = k.db.find(event.match, event.selector, event.index, event.delta)
    nr = 0
    for o in objs:
        ob.edit(o, event.setter)
        o.save()
        nr += 1
    event.reply("edit %s" % nr)

def rm(event):
    """ enable the _deleted flag on an object. """
    if not event.args:
        event.reply("rm <selector>")
        return
    nr = -1
    for o in k.db.find(event.match, event.selector, event.index, event.delta):
        if not o:
            continue
        nr += 1
        o._deleted = True
        o.save()
    event.reply("ok %s" % (nr+1))

def undel(event):
    """ remove the _deleted flag from an object. """
    if not event.args:
        event.reply("undel <selector>")
        return
    st = time.time()
    nr = -1
    for o in k.db.all(event.match, event.selector, event.index, event.delta):
        nr += 1
        o._deleted = False
        o.save()
    event.reply("ok %s %s" % (nr+1, elapsed(time.time()-st)))

def main():
    parse_cli("obs", __version__, opts, hd(".obot"), "obs [options]")
    k.walk("obot.cmd")
    k.cmds.register("ed", ed)
    k.cmds.register("rm", rm)
    k.cmds.register("undel", undel)
    k.init(k.cfg.modules)
    k.start()
    k.wait()
        
execute(main)
os._exit(0)
